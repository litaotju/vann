#crop the images produced by vann
import cv2
import sys
import os
import copy
import threading
import Queue

import numpy as np
from PIL import Image

from vann import mkdir, MosaicHelper

def isvalid_box(box):
    return len(box) == 4 and box[2] >= 0 and box[3] >= 0

def parse_annotations(boxes_file):
    '''@brief given an annotation file, parse the annotations.
       @para  boxes_file, an annotation file generated by vann.py 
       @return anns, a dict, the key image file name, the value is a tumple (box, iou)
                     'box' has a format of (x, y, h, w),
                     'iou' is the intersect of union with ground truth box drawed by user
    '''
    print("Info: begin processing file %s" % boxes_file)
    anns = {}
    invalid_cnt = 0
    with open(boxes_file, 'r') as fobj:
        line_no = 0
        for line in fobj:
            line_no += 1
            try :
                f, box, iou = line.strip().split(":")
                f = os.path.basename(f)
                f = f.strip()
                box = eval(box)
                if not isvalid_box(box):
                    invalid_cnt += 1
                    print ("Info: invalid line:{}".format(line))
                    continue
                #may be negative, but that's fine, we can make it zero
                box = [max(int(_), 0) for _ in box]
                anns[f] = (box, iou)
            except Exception, e:
                print("Error: problem when processing %s:%d %s" % \
                         (boxes_file, line_no, line) )
                anns = {}
                break
    print("Info: invalid box entry count:{}".format(invalid_cnt))
    print("Info: end   processing file %s\n" % boxes_file)
    return anns

###############################################################################
#
###############################################################################

class TaskOnBox(object):

    def __init__(self, filename, box):
        self._filename = filename
        self._box = box

    def run(self):
        raise Exception("This has been implemented")

class TaskOneInOneOut(TaskOnBox):
    def __init__(self, input_fname, box, output_fname):
        super(TaskOneInOneOut, self).__init__(input_fname, box)
        self._output_filename = output_fname

class BatchProcessForBoxesFiles(object):

    def __init__(self, boxes_file_dir, ann_basedir, output_dir, batch_prefix):
        self._boxes_file_dir = boxes_file_dir
        self._ann_basedir = ann_basedir

        #the output will under output_dir/batch_prefix
        self._output_dir = output_dir
        self._batch_prefix = batch_prefix

        self._threaded = False
        self._thread_num = 4
        self._queue = None 

    def run_batch(self):
        self._create_dirs()

        files = []
        if os.path.isfile(self._boxes_file_dir):
            files = [self._boxes_file_dir]
        else:
            files = [ os.path.join(self._boxes_file_dir, f) \
                       for f in os.listdir(self._boxes_file_dir)\
                           if os.path.isfile(f) ]

        if not self._threaded:
            for boxes_file in files:
                self._process_file(boxes_file, self._ann_basedir, self._output_dir)
        else:
            self._queue = Queue.Queue()
            self.__produce_tasks(files)

            threads = [threading.Thread(target=self.dispatch_tasks) \
                             for _ in range(self._thread_num)]
            for t in threads:
                t.setDaemon(True)
                t.start()

            self._queue.join()

    def _create_dirs(self):
        mkdir(self._output_dir)
        mkdir(self._output_dir, self._batch_prefix)

    def _process_file(self, boxes_file, ann_basedir, output_dir):
        anns = parse_annotations(boxes_file)
        for f, (box,iou) in anns.items():
            raw_img = os.path.join(ann_basedir,  "raw_images", f)
            raw_img_o = os.path.join(output_dir, self._batch_prefix, f)
            self._get_task(raw_img, box, raw_img_o).run()

    def __produce_tasks(self, files):
        for boxes_file in files:
            anns = parse_annotations(boxes_file)
            for f, (box,iou) in anns.items():
                raw_img = os.path.join(self._ann_basedir,  "raw_images", f)
                raw_img_o = os.path.join(self._output_dir, self._batch_prefix, f)
                task = self._get_task(raw_img, box, raw_img_o)
                self._queue.put(task)
        print ("Put Done")

    def dispatch_tasks(self):
        while True:
            t = self._queue.get()
            t.run()
            self._queue.task_done()
        print ("Dispatch done")

    def _get_task(self, input_fname, box, output_fname):
        raise AssertionError, "not implemented"

    def set_threaded(self, thread_num=4):
        self._threaded = True
        self._threaded = 4
        return self

###############################################################################
# 
###############################################################################
class TaskCrabOnBox(TaskOneInOneOut):

    def run(self):
        box = copy.copy(self._box)
        img = Image.open(self._filename)
        box = self.__adapt_box(img, box)
        img = img.crop((box[0], box[1], box[0]+box[2], box[1]+box[3]))
        img.save(self._output_filename)

    def __adapt_box(self, img, orig_box):
        #adapt the box to proper scale ans ratio
        mosaic_img = img
        # make it 1:1
        size = min(max(orig_box[3], orig_box[2]), min(mosaic_img.size[:2]) )
        orig_box[0] -= abs(size-orig_box[2])/2
        orig_box[1] -= abs(size-orig_box[3])/2
        orig_box[0] = max(orig_box[0], 0)
        orig_box[1] = max(orig_box[1], 0)
        orig_box[3] = orig_box[2] = size

        #adopt principle is the cropped image not bigger than
        #original image, and no padding is needed
        SIZE = min(400, min(mosaic_img.size[:2]))
        need_resize = True
        assert orig_box[2] == orig_box[3]
        if orig_box[2] < SIZE:
            orig_box[0] -= (SIZE-orig_box[2])/2
            orig_box[1] -= (SIZE-orig_box[2])/2
            orig_box[2] = orig_box[3] = SIZE
            need_resize = False
            orig_box[1] = max(orig_box[1], 0)
            orig_box[0] = max(orig_box[0], 0)

        #move to proper location
        assert orig_box[2] == orig_box[3] and  \
             orig_box[2] <= mosaic_img.size[0] and \
             orig_box[3] <= mosaic_img.size[1] 
        if orig_box[0] + orig_box[2] > mosaic_img.size[0]:
            orig_box[0] = mosaic_img.size[0] - orig_box[2]
        if orig_box[1] + orig_box[3] > mosaic_img.size[1]:
            orig_box[1] = mosaic_img.size[1] - orig_box[3]
        return orig_box


class BatchCrop(BatchProcessForBoxesFiles):

    def _create_dirs(self):
        super(BatchCrop, self)._create_dirs()
        self._output_dir =  os.path.join(self._output_dir, self._batch_prefix)
        mkdir(self._output_dir, "mosaic_images")
        mkdir(self._output_dir, "raw_images")

    def _process_file(self, boxes_file, ann_basedir, output_dir):
         '''@brief given an bound_box file, execute sth. on each (image, box) pair, and store the result on output dir
            @para  boxes_file, file genearated by vann.py
                   ann_basedir, annotation base dir, which should have the "mosaic_image" and "raw_image" directory pair
                   outputdir, the output of this script
         '''
         anns = parse_annotations(boxes_file)
     
         #To stat the QoR
         invalid_file = 0
         for f in anns:
             raw_img = os.path.join(ann_basedir, 'raw_images', f)
             mosaic_img = os.path.join(ann_basedir, 'mosaic_images', f)
     
             raw_img_o = os.path.join(output_dir, "raw_images", f)
             mosaic_img_o = os.path.join(output_dir, 'mosaic_images', f)
     
             check_file = True
             for _ in (mosaic_img, raw_img):
                 if not os.path.exists(_):
                     print ("%s no exist" % _)
                     invalid_file += 1
                     check_file = False
     
             if not check_file:
                 continue
     
             orig_box = anns[f][0]
             TaskCrabOnBox(mosaic_img, orig_box, mosaic_img_o).run()
             TaskCrabOnBox(raw_img, orig_box, raw_img_o).run()
     
             #if need_resize:
             #    mosaic_img = mosaic_img.resize((SIZE, SIZE))
             #    raw_img = raw_img.resize((SIZE, SIZE))
         print ("Numer of files missed: %d" % invalid_file)
     
###############################################################################
#
###############################################################################
class TaskMosaicOnBox(TaskOneInOneOut):
    MOSAIC_SIZE = 10

    def run(self):
        image = cv2.imread(self._filename)
        if image is None:
            print("Warning: can not find %s", self._filename)
            return
        MosaicHelper.mosaic_on_bound_box(image, self._box, self.MOSAIC_SIZE)
        cv2.imwrite(self._output_filename, image)


class BatchMosaic(BatchProcessForBoxesFiles):

    def _get_task(self, input_fname, box, output_fname):
        return TaskMosaicOnBox(input_fname, box, output_fname)

###############################################################################
#
###############################################################################
class TaskGrabCutOnBox(TaskOneInOneOut):

    ITER_NUM = 5
    def run(self):
        box = tuple(self._box)
        img = cv2.imread(self._filename)

        mask = np.zeros(img.shape[:2],np.uint8)
        bgdModel = np.zeros((1,65),np.float64)
        fgdModel = np.zeros((1,65),np.float64)

        cv2.grabCut(img, mask, box, bgdModel, fgdModel, \
                      TaskGrabCutOnBox.ITER_NUM, cv2.GC_INIT_WITH_RECT)

        mask2 = np.where((mask==2)|(mask==0),0,1).astype('uint8')
        img = img*mask2[:,:,np.newaxis]
        cv2.imwrite(self._output_filename, img)


class BatchGrabCut(BatchProcessForBoxesFiles):

    def _get_task(self, input_fname, box, output_fname):
        return TaskGrabCutOnBox(input_fname, box, output_fname)

###############################################################################
#
###############################################################################

def main():
    # Where there are *txts, each row is one item, contains image, bound_box, iou
    boxes_file_dir = sys.argv[1]

    # Where there aro two directories, "mosaic_images"/"raw_images", where stores the images addressed in boxes file
    ann_basedir = sys.argv[2]

    # Where there output directory is.
    output_dir = sys.argv[3]

    mode = sys.argv[4] 
    print boxes_file_dir, ann_basedir, output_dir

    assert output_dir != ann_basedir, "This would over write the original data"

    if mode == 'c':
        BatchCrop(boxes_file_dir, ann_basedir, output_dir, "cropped").run_batch()
    if mode == 'g':
        BatchGrabCut(boxes_file_dir, ann_basedir, output_dir, "grabcut_images_thread").set_threaded().run_batch()
    if mode == 'gs':
        BatchGrabCut(boxes_file_dir, ann_basedir, output_dir, "grabcut_images").run_batch()
    if mode == 'm':
        BatchMosaic(boxes_file_dir, ann_basedir, output_dir, "mosaic_images").set_threaded().run_batch()
    if mode == 'ms':
        BatchMosaic(boxes_file_dir, ann_basedir, output_dir, "mosaic_images").run_batch()


if __name__ == "__main__":
    main()
